{
  "schemaVersion": "1.0",
  "generator": "kb-labs-mind@0.1.0",
  "docs": [
    {
      "title": "CLI Architecture",
      "path": "docs/ARCHITECTURE.md",
      "tags": [],
      "summary": "The KB Labs CLI follows a layered architecture with clear separation of concerns: **Responsibility:** Entry point, global orchestration **Key file:** The CLI layer: 1. Parses command-line arguments 2. Extracts global flags (, , etc.) 3. Creates appropriate presenter (JSON or Text) 4. Executes command with context 5. Wraps results for JSON mode 6. Handles errors uniformly **JSON Mode Pipeline:** **Responsibility:** Business logic, command implementation Commands follow one of two patterns: For straightforward commands, return data object: CLI automatically wraps: For complex output, use : **Responsibility:** Shared abstractions and utilities Passed to every command: Unified output interface: **Behavior by mode:** | Method | Text Mode | JSON Mode | |---------|------------------------|--------------------------| | write() | console.log() | no-op | | warn() | console.warn() | → ctx.diagnostics[] | | error() | console.error() | console.log(JSON error) | | json() | throw Error | console.log(JSON) | 1. **Add new commands** - Implement interface in 2. **Add...",
      "type": "guide"
    },
    {
      "title": "Command Registration Quick Reference",
      "path": "docs/COMMAND_QUICK_REFERENCE.md",
      "tags": [],
      "summary": "All commands support these global flags: - - Output results in JSON format - - Suppress non-essential output - - Show command help - - Show CLI version When is used, commands will output structured JSON: All JSON output follows this schema: **Success:** **Error:** 1. Create command file in 2. Add to : 3. Export in : 1. Create command file in 2. Create/update 3. Add to : **Simple commands (recommended):** **Complex commands:** Unified exit code system across all commands: - - Success - - Generic error - - Preflight cancelled (user cancelled operation) - - Invalid flags (validation error) 1. **Always include flag** for commands with output 2. **Use ** for commands that make changes 3. **Provide meaningful examples** in the array 4. **Include ** for backward compatibility 5. **Return appropriate exit codes** 6. **Handle both text and JSON output modes** 7. **Use consistent naming** (kebab-case for commands) 8....",
      "type": "guide"
    },
    {
      "title": "Command Registration Guide",
      "path": "docs/COMMAND_REGISTRATION.md",
      "tags": [],
      "summary": "This guide explains how to register new commands in the KB Labs CLI using the new git-style command groups architecture. The CLI now supports two types of commands: - **Standalone commands**: Direct commands like , - **Group commands**: Commands organized by product like , All commands must implement the interface: Define command flags using the interface: For system-level commands that don't belong to a specific product: 1. **Create the command file** in : 2. **Register the command** in : 3. **Export the command** in : For commands that belong to a product group (recommended for most commands): 1. **Create the command file** in the appropriate group directory: 2. **Create or update the group index** file: 3. **Register the group** in : All CLI commands should follow a consistent output pattern for better user experience and maintainability. Use the utility from for structured command output: Use for commands that perform multiple...",
      "type": "guide"
    },
    {
      "title": "DevLink Commands Reference",
      "path": "docs/DEVLINK_COMMANDS.md",
      "tags": [],
      "summary": "Quick reference for all DevLink commands with examples and common use cases. | Command | Purpose | Changes Files | |---------|---------|---------------| | | Analyze dependencies | No | | | Lock → Manifests snapshot | | | | Manifests ← Lock | | | | Manifests ← Lock (sync only) | | | | Revert last operation | Varies | | | Show current state | No | | | Manage backups | No | **Purpose:** Capture current dependency state into lock file **What happens:** 1. Scans all package.json files 2. Resolves versions from pnpm-lock.yaml 3. Creates/updates 4. Backs up old lock.json to 5. Auto-cleanup old backups **Output:** **Purpose:** Modify package.json files according to lock **What happens:** 1. Reads 2. Backs up current package.json files to 3. Modifies dependencies in package.json 4. Changes protocols (e.g., → ) 5. Auto-cleanup old backups **Example change:** **Purpose:** Update package.json versions to match lock...",
      "type": "guide"
    },
    {
      "title": "KB Labs CLI Documentation",
      "path": "docs/README.md",
      "tags": [],
      "summary": "This directory contains comprehensive documentation for the KB Labs CLI project. - **[COMMAND_QUICK_REFERENCE.md](./COMMAND_QUICK_REFERENCE.md)** - Quick reference for command development - **[COMMAND_REGISTRATION.md](./COMMAND_REGISTRATION.md)** - Complete guide for registering new commands - **[guides/cli-style.md](./guides/cli-style.md)** - CLI design principles and conventions - **[guides/command-output.md](./guides/command-output.md)** - Detailed command output formatting guide - **[ADR 0001: Architecture and Repository Layout](./adr/0001-architecture-and-reposity-layout.md)** - Project structure - **[ADR 0002: Plugins and Extensibility](./adr/0002-plugins-and-extensibility.md)** - Plugin system design - **[ADR 0003: Package and Module Boundaries](./adr/0003-package-and-module-boundaries.md)** - Package organization - **[ADR 0004: Versioning and Release Policy](./adr/0004-versioning-and-release-policy.md)** - Versioning strategy - **[ADR 0005: Unified CLI Output Formatting](./adr/0005-unified-cli-output-formatting.md)** - Output formatting standards - **[DEVLINK_COMMANDS.md](./DEVLINK_COMMANDS.md)** - DevLink command reference - **[ARCHITECTURE.md](./ARCHITECTURE.md)** - Overall system architecture **New to CLI development?** 1. Start with [CLI Style Guide](./guides/cli-style.md) for design principles 2. Follow [Command Quick Reference](./COMMAND_QUICK_REFERENCE.md) for basic patterns 3. Use [Command Registration Guide](./COMMAND_REGISTRATION.md) for detailed implementation **Adding a new command?** 1. **Design**: Follow [CLI Style Guide](./guides/cli-style.md) principles 2. **Implement**: Use...",
      "type": "readme"
    },
    {
      "title": "ADR-0001: Architecture and Repository Layout",
      "path": "docs/adr/0001-architecture-and-reposity-layout.md",
      "tags": [],
      "summary": "**Date:** 2025-09-13 **Status:** Accepted **Deciders:** KB Labs Team KB Labs products must be consistent across repositories. Each repository should follow the same monorepo-style layout to support apps, packages, and fixtures. - Use PNPM workspaces for package management - Repository root must contain: - — example/demo apps or product UI - — core logic, reusable libraries, domain modules - — sample diffs, test inputs, reference data - — ADRs, handbook, guides - Shared configs (tsconfig, eslint, prettier, vitest) live in root **Positive:** - Consistent developer experience across products - Easy onboarding: all repositories look alike - Enables cross-product reuse of tools/scripts **Negative:** - Initial setup complexity for new repositories",
      "type": "adr"
    },
    {
      "title": "ADR-0002: Plugins and Extensibility",
      "path": "docs/adr/0002-plugins-and-extensibility.md",
      "tags": [],
      "summary": "**Date:** 2025-09-13 **Status:** Accepted **Deciders:** KB Labs Team KB Labs products are designed to be reusable across different stacks, domains, and teams. To ensure long-term scalability, all products (AI Review, AI Docs, AI Tests, etc.) must support a flexible plugin & extension system. Without this, every new feature would require hardcoding into the core, increasing maintenance burden and reducing adaptability. - Each KB Labs product must expose a plugin API that allows third-party developers (or other KB Labs packages) to extend behavior without modifying the core - The plugin system must be: 1. **Isolated** — Plugins run in a sandboxed scope and cannot break the core 2. **Composable** — Multiple plugins can be combined in one pipeline 3. **Discoverable** — Plugins are registered via a central registry () or a configuration file () 4. **Typed** — All plugin interfaces must be defined in using TypeScript types and Zod schemas 5....",
      "type": "adr"
    },
    {
      "title": "ADR-0003: Package and Module Boundaries",
      "path": "docs/adr/0003-package-and-module-boundaries.md",
      "tags": [],
      "summary": "**Date:** 2025-09-13 **Status:** Accepted **Deciders:** KB Labs Team Products in KB Labs often require multiple internal packages. Without strict boundaries, cross-dependencies can grow messy and unmaintainable. - Every package under must define: - — implementation - — public entry point - — exported types & schemas - Packages must only depend on public exports of other packages - Cross-package imports must use workspace aliases () - Domain rules: - Core logic in - Product-specific code in - Experimental code → feature packages, not core **Positive:** - Prevents tight coupling - Core remains minimal and reusable - Easier to extract packages as standalone OSS later **Negative:** - Requires discipline to maintain boundaries - More complex dependency management",
      "type": "adr"
    },
    {
      "title": "ADR-0004: Versioning and Release Policy",
      "path": "docs/adr/0004-versioning-and-release-policy.md",
      "tags": [],
      "summary": "**Date:** 2025-09-13 **Status:** Accepted **Deciders:** KB Labs Team The KB Labs ecosystem must stay consistent, while still allowing individual products to evolve. - Use Semantic Versioning (SemVer) for all published packages - Core () follows stricter rules: - **MAJOR:** breaking changes in APIs/schemas - **MINOR:** new features, backward-compatible - **PATCH:** bugfixes - Products (, , , etc.) can release independently, but must pin to compatible core versions - Changelog generation automated via changesets or - Release flow: 1. Pull request → CI check (lint, type-check, test) 2. Merge → changeset entry created 3. Release pipeline tags version, publishes to npm, updates changelog **Positive:** - Predictable updates across ecosystem - Users know when breaking changes occur - Easy adoption of multiple products without fear of hidden breakage **Negative:** - Requires careful coordination for major releases - More complex release automation setup",
      "type": "adr"
    },
    {
      "title": "ADR-0005: Unified CLI Output Formatting",
      "path": "docs/adr/0005-unified-cli-output-formatting.md",
      "tags": [],
      "summary": "**Accepted** - 2025-10-27 The KB Labs CLI ecosystem consists of multiple packages (kb-labs-cli, kb-labs-devlink, kb-labs-mind) with different output formatting styles. This inconsistency creates: - **Poor user experience** - Users see different output styles across commands - **Maintenance overhead** - Each package implements its own formatting logic - **Inconsistent timing display** - Some commands show timing, others don't - **No standardized error handling** - Different error presentation patterns We will implement a **unified CLI output formatting system** with the following characteristics: 1. **Box Formatting** - All command outputs use consistent box-style formatting with titles 2. **Timing Display** - All commands show execution time using 3. **Summary Metrics** - Commands display key-value summary information 4. **JSON Mode Support** - All commands support flag for machine-readable output 5. **Shared Utilities** - Common formatting logic moved to **Shared Package Structure:** **Command Pattern:** **Commands Updated:** - All devlink commands (plan, apply, freeze, undo, switch, update,...",
      "type": "adr"
    },
    {
      "title": "ADR-0006: Legacy Command Migration to Manifest System",
      "path": "docs/adr/0006-legacy-command-migration-to-manifest-system.md",
      "tags": [],
      "summary": "**Date:** 2025-10-27 **Status:** Accepted **Deciders:** KB Labs Team The KB Labs CLI was initially built with a mixed architecture where some commands were registered directly in the core CLI package () while others used a manifest-based plugin system. This created several problems: - **Inconsistent Architecture** - Some commands (profiles, bundle, init, mind) were hardcoded in CLI core - **Tight Coupling** - Business logic was mixed with CLI infrastructure - **Maintenance Burden** - Changes to business commands required CLI package updates - **Code Duplication** - Similar commands across different packages had different implementations - **Poor Separation of Concerns** - CLI infrastructure and business logic were intertwined We will migrate all business logic commands from direct registration to a **manifest-based plugin system**, keeping only system commands in the CLI core. These commands are infrastructure-related and belong in the CLI core: - - Basic CLI functionality test - - CLI version information -...",
      "type": "adr"
    },
    {
      "title": "ADR-0007: System Commands UX/UI Unification",
      "path": "docs/adr/0007-system-commands-ux-ui-unification.md",
      "tags": [],
      "summary": "**Date:** 2025-10-27 **Status:** Accepted **Deciders:** KB Labs Team After migrating business commands to the manifest system, the remaining system commands in the CLI core had inconsistent output formatting: - **** - Simple text output without formatting - **** - Plain key=value format - **** - Basic success/error messages - **** - Already had box formatting (updated earlier) - **** - Already had box formatting This inconsistency violated the unified CLI output principles established in ADR-0005 and created a poor user experience where system commands looked different from business commands. We will unify all system commands to use the same UX/UI patterns as business commands, implementing the unified CLI output formatting system from ADR-0005. **Core Components:** - - Consistent box formatting with titles - - Structured key-value pair display - - Execution timing measurement - and - Consistent color and symbol usage - JSON mode support with information - Unified error...",
      "type": "adr"
    },
    {
      "title": "CLI Style Guide",
      "path": "docs/guides/cli-style.md",
      "tags": [],
      "summary": "This guide establishes consistent design principles and conventions for all KB Labs CLI tools. - All commands should follow the same output patterns - Use shared utilities from - Maintain consistent error handling across all commands - Prioritize readability and clarity - Show relevant information without overwhelming users - Provide helpful suggestions and next steps - Always show execution timing - Use for multi-phase operations - Display progress indicators for long-running operations - Use **kebab-case**: , - Use **verbs** for actions: , , , - Use **nouns** for queries: , , - Keep names **short and descriptive** - Use **kebab-case**: , - Use **descriptive names**: not - Provide **aliases** for common flags: for - Use **boolean flags** for toggles: , Use formatting for all command outputs: **Output:** **✅ Use box formatting for:** - Commands that perform operations (apply, switch, freeze) - Commands that show status or results (status, plan, version)...",
      "type": "guide"
    },
    {
      "title": "Command Output Formatting Guide",
      "path": "docs/guides/command-output.md",
      "tags": [],
      "summary": "This guide explains how to format CLI command outputs consistently across all KB Labs commands using the unified output pattern. All CLI commands should follow a consistent output pattern that includes: - **Box formatting** for structured output - **Timing information** for performance visibility - **Summary metrics** showing what was accomplished - **Consistent error handling** and diagnostics **Use box formatting for:** - Commands that perform operations (apply, switch, freeze, etc.) - Commands that show status or results (status, plan, version) - Commands that process data (feed, pack, update) **Don't use box formatting for:** - Simple informational commands (hello) - Commands with very long detailed output (keep detailed output, add summary box at end) **Output:** **Output:** Use for commands with multiple phases: Timing is automatically formatted for readability: - : - : - : Use for consistent summary formatting: **For file operations:** - : Number of files processed - : Number of...",
      "type": "guide"
    },
    {
      "title": "ADR-0001: Architecture and Repository Layout",
      "path": "docs/adr/0001-architecture-and-reposity-layout.md",
      "tags": [],
      "summary": "**Date:** 2025-09-13 **Status:** Accepted **Deciders:** KB Labs Team KB Labs products must be consistent across repositories. Each repository should follow the same monorepo-style layout to support apps, packages, and fixtures. - Use PNPM workspaces for package management - Repository root must contain: - — example/demo apps or product UI - — core logic, reusable libraries, domain modules - — sample diffs, test inputs, reference data - — ADRs, handbook, guides - Shared configs (tsconfig, eslint, prettier, vitest) live in root **Positive:** - Consistent developer experience across products - Easy onboarding: all repositories look alike - Enables cross-product reuse of tools/scripts **Negative:** - Initial setup complexity for new repositories",
      "type": "adr"
    },
    {
      "title": "ADR-0002: Plugins and Extensibility",
      "path": "docs/adr/0002-plugins-and-extensibility.md",
      "tags": [],
      "summary": "**Date:** 2025-09-13 **Status:** Accepted **Deciders:** KB Labs Team KB Labs products are designed to be reusable across different stacks, domains, and teams. To ensure long-term scalability, all products (AI Review, AI Docs, AI Tests, etc.) must support a flexible plugin & extension system. Without this, every new feature would require hardcoding into the core, increasing maintenance burden and reducing adaptability. - Each KB Labs product must expose a plugin API that allows third-party developers (or other KB Labs packages) to extend behavior without modifying the core - The plugin system must be: 1. **Isolated** — Plugins run in a sandboxed scope and cannot break the core 2. **Composable** — Multiple plugins can be combined in one pipeline 3. **Discoverable** — Plugins are registered via a central registry () or a configuration file () 4. **Typed** — All plugin interfaces must be defined in using TypeScript types and Zod schemas 5....",
      "type": "adr"
    },
    {
      "title": "ADR-0003: Package and Module Boundaries",
      "path": "docs/adr/0003-package-and-module-boundaries.md",
      "tags": [],
      "summary": "**Date:** 2025-09-13 **Status:** Accepted **Deciders:** KB Labs Team Products in KB Labs often require multiple internal packages. Without strict boundaries, cross-dependencies can grow messy and unmaintainable. - Every package under must define: - — implementation - — public entry point - — exported types & schemas - Packages must only depend on public exports of other packages - Cross-package imports must use workspace aliases () - Domain rules: - Core logic in - Product-specific code in - Experimental code → feature packages, not core **Positive:** - Prevents tight coupling - Core remains minimal and reusable - Easier to extract packages as standalone OSS later **Negative:** - Requires discipline to maintain boundaries - More complex dependency management",
      "type": "adr"
    },
    {
      "title": "ADR-0004: Versioning and Release Policy",
      "path": "docs/adr/0004-versioning-and-release-policy.md",
      "tags": [],
      "summary": "**Date:** 2025-09-13 **Status:** Accepted **Deciders:** KB Labs Team The KB Labs ecosystem must stay consistent, while still allowing individual products to evolve. - Use Semantic Versioning (SemVer) for all published packages - Core () follows stricter rules: - **MAJOR:** breaking changes in APIs/schemas - **MINOR:** new features, backward-compatible - **PATCH:** bugfixes - Products (, , , etc.) can release independently, but must pin to compatible core versions - Changelog generation automated via changesets or - Release flow: 1. Pull request → CI check (lint, type-check, test) 2. Merge → changeset entry created 3. Release pipeline tags version, publishes to npm, updates changelog **Positive:** - Predictable updates across ecosystem - Users know when breaking changes occur - Easy adoption of multiple products without fear of hidden breakage **Negative:** - Requires careful coordination for major releases - More complex release automation setup",
      "type": "adr"
    },
    {
      "title": "ADR-0005: Unified CLI Output Formatting",
      "path": "docs/adr/0005-unified-cli-output-formatting.md",
      "tags": [],
      "summary": "**Accepted** - 2025-10-27 The KB Labs CLI ecosystem consists of multiple packages (kb-labs-cli, kb-labs-devlink, kb-labs-mind) with different output formatting styles. This inconsistency creates: - **Poor user experience** - Users see different output styles across commands - **Maintenance overhead** - Each package implements its own formatting logic - **Inconsistent timing display** - Some commands show timing, others don't - **No standardized error handling** - Different error presentation patterns We will implement a **unified CLI output formatting system** with the following characteristics: 1. **Box Formatting** - All command outputs use consistent box-style formatting with titles 2. **Timing Display** - All commands show execution time using 3. **Summary Metrics** - Commands display key-value summary information 4. **JSON Mode Support** - All commands support flag for machine-readable output 5. **Shared Utilities** - Common formatting logic moved to **Shared Package Structure:** **Command Pattern:** **Commands Updated:** - All devlink commands (plan, apply, freeze, undo, switch, update,...",
      "type": "adr"
    },
    {
      "title": "ADR-0006: Legacy Command Migration to Manifest System",
      "path": "docs/adr/0006-legacy-command-migration-to-manifest-system.md",
      "tags": [],
      "summary": "**Date:** 2025-10-27 **Status:** Accepted **Deciders:** KB Labs Team The KB Labs CLI was initially built with a mixed architecture where some commands were registered directly in the core CLI package () while others used a manifest-based plugin system. This created several problems: - **Inconsistent Architecture** - Some commands (profiles, bundle, init, mind) were hardcoded in CLI core - **Tight Coupling** - Business logic was mixed with CLI infrastructure - **Maintenance Burden** - Changes to business commands required CLI package updates - **Code Duplication** - Similar commands across different packages had different implementations - **Poor Separation of Concerns** - CLI infrastructure and business logic were intertwined We will migrate all business logic commands from direct registration to a **manifest-based plugin system**, keeping only system commands in the CLI core. These commands are infrastructure-related and belong in the CLI core: - - Basic CLI functionality test - - CLI version information -...",
      "type": "adr"
    },
    {
      "title": "ADR-0007: System Commands UX/UI Unification",
      "path": "docs/adr/0007-system-commands-ux-ui-unification.md",
      "tags": [],
      "summary": "**Date:** 2025-10-27 **Status:** Accepted **Deciders:** KB Labs Team After migrating business commands to the manifest system, the remaining system commands in the CLI core had inconsistent output formatting: - **** - Simple text output without formatting - **** - Plain key=value format - **** - Basic success/error messages - **** - Already had box formatting (updated earlier) - **** - Already had box formatting This inconsistency violated the unified CLI output principles established in ADR-0005 and created a poor user experience where system commands looked different from business commands. We will unify all system commands to use the same UX/UI patterns as business commands, implementing the unified CLI output formatting system from ADR-0005. **Core Components:** - - Consistent box formatting with titles - - Structured key-value pair display - - Execution timing measurement - and - Consistent color and symbol usage - JSON mode support with information - Unified error...",
      "type": "adr"
    }
  ],
  "count": 21,
  "generatedAt": "2025-10-28T10:08:14.018Z"
}